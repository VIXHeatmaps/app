<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Heatmap Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    .formula { font-style: italic; margin-bottom: 20px; }
    .header { display: flex; justify-content: space-between; align-items: flex-start; }
    .controls { flex: 1; }
    .upload-box { border: 1px solid #ccc; padding: 8px; border-radius: 6px; margin-bottom: 8px; }
    .control { margin-bottom: 12px; }
    label { font-weight: bold; margin-right: 8px; }
    input[type=range] { width: 250px; vertical-align: middle; }
    input[type=number] { width: 60px; margin-left: 8px; }
    #currentMaxH { margin-left: 12px; font-weight: bold; }
    .toggle-box { margin-top: 8px; }
    .switch { position: relative; display: inline-block; width: 40px; height: 20px; margin: 0 6px; vertical-align: middle; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; transition: .4s; border-radius: 20px; }
    .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background: #4CAF50; }
    input:checked + .slider:before { transform: translateX(20px); }
    .format-label { vertical-align: middle; }
    #edgeContainer { display: flex; align-items: flex-start; }
    #hoverY { width: 80px; text-align: right; margin-right: 8px; min-height: 60vh; line-height: 60vh; font-weight: bold; }
    #heatmap { flex: 1; height: 60vh; }
    #hoverX-container { display: flex; justify-content: center; margin-top: 8px; }
    #hoverX { font-style: italic; color: #333; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Heatmap Viewer</h2>
  <div class="formula">
    <strong>Metric:</strong> H = (AR – AR<sub>min</sub>) / max(MD, MD<sub>min</sub>) (decimal)
  </div>

  <div class="header">
    <div class="controls">
      <div class="control">
        <label>Symbol:</label>
        <select id="symbolSelect"></select>
      </div>
      <div class="control">
        <label>AR Min. (%):</label>
        <input type="range" id="arFloor" min="0" max="100" step="0.1" value="1">
        <input type="number" id="arFloorNum" min="0" max="100" step="0.1" value="1">
      </div>
      <div class="control">
        <label>MD Min. (%):</label>
        <input type="range" id="mdMin" min="0" max="100" step="0.1" value="3">
        <input type="number" id="mdMinNum" min="0" max="100" step="0.1" value="3">
      </div>
      <div class="control">
        <label>MD Max (%):</label>
        <input type="range" id="mdCeil" min="0" max="100" step="0.1" value="25">
        <input type="number" id="mdCeilNum" min="0" max="100" step="0.1" value="25">
      </div>
      <div class="control">
        <label>Colorbar Min H:</label>
        <input type="number" id="zMin" step="0.01" value="-1">
        <label>Colorbar Max H:</label>
        <input type="number" id="zMax" step="0.01" value="1">
        <span id="currentMaxH">Current Max H: --</span>
      </div>
    </div>

    <div>
      <div class="upload-box">
        <div class="control">
          <label>Upload CSV:</label>
          <input type="file" id="csvInput" accept=".csv">
        </div>
      </div>
      <div class="toggle-box">
        <span class="format-label">×0.01</span>
        <label class="switch">
          <input type="checkbox" id="percentToggle" checked>
          <span class="slider"></span>
        </label>
        <span class="format-label">×100</span>
      </div>
    </div>
  </div>

  <div id="edgeContainer">
    <div id="hoverY"></div>
    <div id="heatmap"></div>
  </div>
  <div id="hoverX-container"><div id="hoverX"></div></div>

  <script>
    // Data storage
    let allData = {};          
    let symbolOrder = [];      
    let rawText = null;

    // Utility: parse a CSV text (handles synonyms) into allData & build symbolOrder
    function buildFromText(text) {
      const rows = text.trim().split(/\\r?\\n/);
      const headers = rows.shift().split(',').map(h => h.trim().toLowerCase());
      // Determine column indices by synonym matching
      const findIdx = synonyms => {
        for (let i=0; i<headers.length; i++) {
          if (synonyms.some(w=>headers[i].includes(w))) return i;
        }
        return null;
      };
      const idxSym = findIdx(['symbol','name','ticker']);
      const idxDay = findIdx(['day','days','lookback','window','timeframe','period']);
      const idxRSI = findIdx(['rsi']);
      const idxAR  = findIdx(['ar','cagr','annualized return','annual return']);
      const idxMD  = findIdx(['md','max drawdown','drawdown']);
      const idxCM  = findIdx(['calmar','calmar ratio']);

      rows.forEach(line => {
        const cols = line.split(',').map(c=>c.trim());
        const s = cols[idxSym], day = +cols[idxDay], rsi = cols[idxRSI];
        let ar = parseFloat(cols[idxAR]), md = parseFloat(cols[idxMD]);
        const cm = parseFloat(cols[idxCM]);
        // Apply conversion toggle
        if (percentToggle.checked) { ar *= 0.01; md *= 0.01; }
        // Initialize if needed
        if (!allData[s]) {
          allData[s] = { entries: [] };
        }
        allData[s].entries.push({ day, rsi, ar, md, cm });
      });

      // Rebuild matrices and symbolOrder
      Object.keys(allData).forEach(s => {
        const E = allData[s].entries;
        const xs = [...new Set(E.map(o=>o.rsi))].sort();
        const ys = [...new Set(E.map(o=>o.day))].sort((a,b)=>a-b);
        const arM = ys.map(y => xs.map(x => {
          const rec = E.find(o=>o.day===y && o.rsi===x);
          return rec? rec.ar : null;
        }));
        const mdM = ys.map(y => xs.map(x => {
          const rec = E.find(o=>o.day===y && o.rsi===x);
          return rec? rec.md : null;
        }));
        const cmM = ys.map(y => xs.map(x => {
          const rec = E.find(o=>o.day===y && o.rsi===x);
          return rec? rec.cm : null;
        }));
        allData[s] = { x: xs, y: ys, ar: arM, md: mdM, cm: cmM };
      });
    }

    // Render the dropdown & initial heatmap
    function populateSymbols() {
      symbolSelect.innerHTML = '';
      symbolOrder.forEach(sym => {
        const opt = document.createElement('option');
        opt.value = opt.text = sym;
        symbolSelect.appendChild(opt);
      });
      if (symbolOrder.length) drawHeatmap();
    }

    // Compute H matrix
    function computeH(ar, md, floor, minMD) {
      return ar.map((row,i) => row.map((v,j) =>
        v==null? null : (v - floor)/Math.max(md[i][j], minMD)
      ));
    }

    // Draw via Plotly
    function drawHeatmap() {
      const s = symbolSelect.value;
      const D = allData[s];
      const floor = +arFloor.value/100;
      const minMD = +mdMin.value/100;
      const ceilMD = +mdCeil.value/100;
      const zmin = +zMin.value, zmax = +zMax.value;

      const H = computeH(D.ar, D.md, floor, minMD);
      // Overlay mask for MD > ceilMD
      const mask = D.md.map(row => row.map(v => v!=null && v>ceilMD?1:0));

      // Update current max H
      let maxH = -Infinity;
      H.forEach(r=>r.forEach(v=> v!=null && v>maxH && (maxH=v)));
      currentMaxH.textContent = 'Current Max H: ' + maxH.toFixed(3);

      Plotly.newPlot(heatmap, [
        {
          z: H, x: D.x, y: D.y, type: 'heatmap',
          colorscale:[[0,'green'],[0.5,'yellow'],[1,'red']],
          zmin, zmax,
          customdata: D.ar.map((r,i)=>r.map((_,j)=>[D.ar[i][j],D.md[i][j],D.cm[i][j],H[i][j]])),
          hovertemplate:
            'AR: %{customdata[0]:.2%}<br>' +
            'MD: %{customdata[1]:.2%}<br>' +
            'Calmar: %{customdata[2]:.2f}<br>' +
            'H: %{customdata[3]:.3f}<extra></extra>'
        },
        {
          z: mask, x: D.x, y: D.y, type:'heatmap', showscale:false,
          colorscale:[[0,'rgba(0,0,0,0)'],[1,'rgba(0,0,0,0.5)']], hoverinfo:'skip'
        }
      ], {
        margin:{l:60,r:60,t:60,b:60},
        xaxis:{title:'RSI Threshold'},
        yaxis:{title:'Lookback (days)'}
      }, {responsive:true});

      // Edge hover labels
      heatmap.on('plotly_hover', e=>{
        const pt = e.points[0];
        hoverX.innerText = 'RSI: ' + pt.x;
        hoverY.innerText = 'Day: ' + pt.y;
      });
      heatmap.on('plotly_unhover', ()=>{
        hoverX.innerText = '';
        hoverY.innerText = '';
      });
    }

    // Wire up controls
    const csvInput     = document.getElementById('csvInput'),
          percentToggle= document.getElementById('percentToggle'),
          symbolSelect = document.getElementById('symbolSelect'),
          arFloor      = document.getElementById('arFloor'),
          arFloorNum   = document.getElementById('arFloorNum'),
          mdMin        = document.getElementById('mdMin'),
          mdMinNum     = document.getElementById('mdMinNum'),
          mdCeil       = document.getElementById('mdCeil'),
          mdCeilNum    = document.getElementById('mdCeilNum'),
          zMin         = document.getElementById('zMin'),
          zMax         = document.getElementById('zMax'),
          currentMaxH  = document.getElementById('currentMaxH'),
          heatmap      = document.getElementById('heatmap'),
          hoverX       = document.getElementById('hoverX'),
          hoverY       = document.getElementById('hoverY');

    // Fetch base data on load
    window.addEventListener('load', () => {
      fetch('./data/FeaverSignals.csv')
        .then(r=>r.text())
        .then(text => {
          rawText = text;
          buildFromText(text);
          symbolOrder = Object.keys(allData);
          populateSymbols();
        })
        .catch(err=>console.error('Failed to load base data:', err));
    });

    // Handle CSV upload
    csvInput.addEventListener('change', e => {
      const reader = new FileReader();
      reader.onload = ev => {
        rawText = ev.target.result;
        buildFromText(rawText);
        // prepend any new symbols
        Object.keys(allData).forEach(s=>{
          if (!symbolOrder.includes(s)) symbolOrder.unshift(s);
        });
        populateSymbols();
      };
      reader.readAsText(e.target.files[0]);
    });

    // Conversion toggle re-runs parsing of rawText
    percentToggle.onchange = () => {
      if (rawText) csvInput.dispatchEvent(new Event('change'));
    };

    // Sync sliders & inputs
    [arFloor, arFloorNum].forEach(el=>el.oninput=_=>{
      arFloor.value = arFloorNum.value = el.value; drawHeatmap();
    });
    [mdMin, mdMinNum].forEach(el=>el.oninput=_=>{
      mdMin.value = mdMinNum.value = el.value; drawHeatmap();
    });
    [mdCeil, mdCeilNum].forEach(el=>el.oninput=_=>{
      mdCeil.value = mdCeilNum.value = el.value; drawHeatmap();
    });
    [zMin, zMax].forEach(el=>el.oninput=drawHeatmap);
    symbolSelect.onchange = drawHeatmap;
  </script>
</body>
</html>
