<script>
  // -- data containers --
  let allData = {};
  let symbolOrder = [];
  let rawText = null;

  // -- CSV parser (same as before) --
  function buildFromText(text) {
    // ... your header-synonym logic & entries-to-matrix code unchanged ...
  }

  // -- dropdown renderer & initial draw --
  function populateSymbols() {
    symbolSelect.innerHTML = '';
    symbolOrder.forEach(s => {
      const opt = document.createElement('option');
      opt.value = opt.text = s;
      symbolSelect.appendChild(opt);
    });
    if (symbolOrder.length) drawHeatmap();
  }

  // -- compute H, drawHeatmap, edge-labels, etc. unchanged --
  function computeH(ar, md, floor, minMD) { /* ... */ }
  function drawHeatmap() { /* ... */ }

  // -- grab all controls once the DOM is ready --
  const csvInput      = document.getElementById('csvInput'),
        percentToggle = document.getElementById('percentToggle'),
        symbolSelect  = document.getElementById('symbolSelect'),
        arFloor       = document.getElementById('arFloor'),
        arFloorNum    = document.getElementById('arFloorNum'),
        mdMin         = document.getElementById('mdMin'),
        mdMinNum      = document.getElementById('mdMinNum'),
        mdCeil        = document.getElementById('mdCeil'),
        mdCeilNum     = document.getElementById('mdCeilNum'),
        zMin          = document.getElementById('zMin'),
        zMax          = document.getElementById('zMax'),
        currentMaxH   = document.getElementById('currentMaxH'),
        heatmap       = document.getElementById('heatmap'),
        hoverX        = document.getElementById('hoverX'),
        hoverY        = document.getElementById('hoverY');

  // -- 1) Startup fetch (relative path) --
  window.addEventListener('load', () => {
    fetch('data/FeaverSignals.csv')
      .then(r => {
        if (!r.ok) throw new Error(r.statusText);
        return r.text();
      })
      .then(text => {
        rawText = text;
        buildFromText(text);
        symbolOrder = Object.keys(allData);
        populateSymbols();
      })
      .catch(err => console.error('Base CSV load failed:', err));
  });

  // -- 2) CSV upload merge --
  csvInput.addEventListener('change', e => {
    const reader = new FileReader();
    reader.onload = ev => {
      rawText = ev.target.result;
      buildFromText(rawText);
      // prepend any brand-new symbols
      Object.keys(allData).forEach(s => {
        if (!symbolOrder.includes(s)) symbolOrder.unshift(s);
      });
      populateSymbols();
    };
    reader.readAsText(e.target.files[0]);
  });

  // -- 3) Conversion toggle re-parses current rawText --
  percentToggle.onchange = () => {
    if (rawText) csvInput.dispatchEvent(new Event('change'));
  };

  // -- 4) Sync sliders/inputs & redraw on change --
  [arFloor,arFloorNum].forEach(el =>
    el.oninput = _ => {
      arFloor.value = arFloorNum.value = el.value;
      drawHeatmap();
    }
  );
  [mdMin,mdMinNum].forEach(el =>
    el.oninput = _ => {
      mdMin.value = mdMinNum.value = el.value;
      drawHeatmap();
    }
  );
  [mdCeil,mdCeilNum].forEach(el =>
    el.oninput = _ => {
      mdCeil.value = mdCeilNum.value = el.value;
      drawHeatmap();
    }
  );
  [zMin,zMax].forEach(el => el.oninput = drawHeatmap);
  symbolSelect.onchange = drawHeatmap;
</script>
