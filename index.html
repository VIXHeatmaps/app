<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Heatmap Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    .formula { font-style: italic; margin-bottom: 20px; }
    .header { display: flex; justify-content: space-between; align-items: flex-start; }
    .controls { flex: 1; }
    .upload-box { border: 1px solid #ccc; padding: 8px; border-radius: 6px; }
    .control { margin-bottom: 12px; }
    label { font-weight: bold; margin-right: 8px; }
    input[type=range] { width: 250px; vertical-align: middle; }
    input[type=number] { width: 60px; margin-left: 8px; }
    #currentMaxH { margin-left: 12px; font-weight: bold; }
    .switch { position: relative; display: inline-block; width: 40px; height: 20px; margin: 0 6px; vertical-align: middle; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; transition: .4s; border-radius: 20px; }
    .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background: #4CAF50; }
    input:checked + .slider:before { transform: translateX(20px); }
    .format-label { vertical-align: middle; }
    #edgeContainer { display: flex; align-items: flex-start; }
    #hoverY { width: 80px; text-align: right; margin-right: 8px; min-height: 60vh; line-height: 60vh; }
    #heatmap { flex: 1; height: 60vh; }
    #hoverX-container { display: flex; justify-content: center; margin-top: 8px; }
    #hoverX { font-style: italic; color: #333; }
  </style>
</head>
<body>
  <h2>Heatmap Viewer</h2>
  <div class="formula">
    <strong>Metric:</strong> H = (AR – AR<sub>min</sub>) / max(MD, MD<sub>min</sub>)
  </div>
  <div class="header">
    <div class="controls">
      <div class="control"><label>Symbol:</label><select id="symbolSelect"></select></div>
      <div class="control"><label>AR Min. (%):</label><input type="range" id="arFloor" min="0" max="100" step="0.1" value="1"><input type="number" id="arFloorNum" min="0" max="100" step="0.1" value="1"></div>
      <div class="control"><label>MD Min. (%):</label><input type="range" id="mdMin" min="0" max="100" step="0.1" value="3"><input type="number" id="mdMinNum" min="0" max="100" step="0.1" value="3"></div>
      <div class="control"><label>MD Ceiling (%):</label><input type="range" id="mdCeil" min="0" max="100" step="0.1" value="25"><input type="number" id="mdCeilNum" min="0" max="100" step="0.1" value="25"></div>
      <div class="control"><label>Colorbar Min H:</label><input type="number" id="zMin" step="0.01" value="-1"><label>Colorbar Max H:</label><input type="number" id="zMax" step="0.01" value="1"><span id="currentMaxH">Current Max H: --</span></div>
    </div>
    <div class="upload-box">
      <div class="control"><label>Upload CSV:</label><input type="file" id="csvInput" accept=".csv"></div>
      <div class="control">
        <label>Data Conversion:</label>
        <span class="format-label">×0.01</span>
        <label class="switch"><input type="checkbox" id="percentToggle" checked><span class="slider"></span></label>
        <span class="format-label">×100</span>
      </div>
    </div>
  </div>
  <div id="edgeContainer"><div id="hoverY"></div><div id="heatmap"></div></div>
  <div id="hoverX-container"><div id="hoverX"></div></div>
  <script>
    // Data store
    let allData = {};
    let rawText = null;

    // Element refs
    const csvInput = document.getElementById('csvInput');
    const pctToggle = document.getElementById('percentToggle');
    const symbolSelect = document.getElementById('symbolSelect');
    const arFloor = document.getElementById('arFloor');
    const arFloorNum = document.getElementById('arFloorNum');
    const mdMin = document.getElementById('mdMin');
    const mdMinNum = document.getElementById('mdMinNum');
    const mdCeil = document.getElementById('mdCeil');
    const mdCeilNum = document.getElementById('mdCeilNum');
    const zMin = document.getElementById('zMin');
    const zMax = document.getElementById('zMax');
    const hoverX = document.getElementById('hoverX');
    const hoverY = document.getElementById('hoverY');
    const currentMaxH = document.getElementById('currentMaxH');
    const heatDiv = document.getElementById('heatmap');

    // Initialize on DOM ready
    window.addEventListener('DOMContentLoaded', () => {
      bindControls();
      loadDefaultCSV();
    });

    function bindControls() {
      csvInput.addEventListener('change', handleUpload);
      pctToggle.addEventListener('change', () => { recalc(); });
      [arFloor, arFloorNum].forEach(el => el.oninput = syncAR);
      [mdMin, mdMinNum].forEach(el => el.oninput = syncMDMin);
      [mdCeil, mdCeilNum].forEach(el => el.oninput = syncMDCeil);
      [zMin, zMax].forEach(el => el.oninput = drawHeatmap);
      symbolSelect.addEventListener('change', drawHeatmap);
    }

    function loadDefaultCSV() {
      fetch('data/FeaverSignalsFormatted.csv')
        .then(res => res.text())
        .then(text => { rawText = text; recalc(true); })
        .catch(err => console.error('Auto-load failed:', err));
    }

    function handleUpload(e) {
      const reader = new FileReader();
      reader.onload = evt => { rawText = evt.target.result; recalc(true); };
      reader.readAsText(e.target.files[0]);
    }

    function recalc(resetSymbol = false) {
      if (!rawText) return;
      buildFromText(rawText);
      if (resetSymbol) populateSymbols();
      else drawHeatmap();
    }

    function populateSymbols() {
      symbolSelect.innerHTML = '';
      Object.keys(allData).forEach(s => {
        const opt = document.createElement('option');
        opt.value = opt.text = s;
        symbolSelect.appendChild(opt);
      });
      if (symbolSelect.options.length) {
        symbolSelect.selectedIndex = 0;
        drawHeatmap();
      }
    }

    function syncAR() { arFloor.value = arFloorNum.value; arFloorNum.value = arFloor.value; drawHeatmap(); }
    function syncMDMin() { mdMin.value = mdMinNum.value; mdMinNum.value = mdMin.value; drawHeatmap(); }
    function syncMDCeil() { mdCeil.value = mdCeilNum.value; mdCeilNum.value = mdCeil.value; drawHeatmap(); }

    function buildFromText(text) {
      const lines = text.trim().split(/\r?\n/).slice(1);
      const tmp = {};
      lines.forEach(line => {
        const cols = line.split(',');
        if (cols.length < 6) return;
        const sym = cols[0].trim();
        const day = +cols[1];
        const rsi = cols[2].trim();
        let ar = parseFloat(cols[3]);
        let md = parseFloat(cols[4]);
        const cm = parseFloat(cols[5]);
        if (pctToggle.checked) { ar /= 100; md /= 100; }
        tmp[sym] = tmp[sym] || [];
        tmp[sym].push({ day, rsi, ar, md, cm });
      });
      allData = {};
      Object.entries(tmp).forEach(([s, arr]) => {
        const xs = Array.from(new Set(arr.map(o => o.rsi))).sort((a,b) => a - b);
        const ys = Array.from(new Set(arr.map(o => o.day))).sort((a,b) => a - b);
        const arM = ys.map(y => xs.map(x => { const r = arr.find(o => o.day===y && o.rsi===x); return r ? r.ar : null; }));
        const mdM = ys.map(y => xs.map(x => { const r = arr.find(o => o.day===y && o.rsi===x); return r ? r.md : null; }));
        const cmM = ys.map(y => xs.map(x => { const r = arr.find(o => o.day===y && o.rsi===x); return r ? r.cm : null; }));
        allData[s] = { x: xs, y: ys, ar: arM, md: mdM, cm: cmM };
      });
    }

    function computeH(ar, md, floor, minMD) {
      return ar.map((row, i) =>
        row.map((v, j) => v == null ? null : (v - floor) / Math.max(md[i][j], minMD))
      );
    }

    function drawHeatmap() {
      const s = symbolSelect.value;
      if (!s || !allData[s]) return;
      const D = allData[s];
      const floor = +arFloor.value / 100;
      const minMD = +mdMin.value / 100;
      const ceilMD = +mdCeil.value / 100;
      const H = computeH(D.ar, D.md, floor, minMD);
      const mask = D.md.map(r => r.map(v => (v != null && v > ceilMD) ? 1 : 0));
      let maxH = -Infinity;
      H.forEach(r => r.forEach(v => { if (v != null && v > maxH) maxH = v; }));
      currentMaxH.textContent = 'Current Max H: ' + maxH.toFixed(3);

      Plotly.newPlot(heatDiv, [
        {
          z: H, x: D.x, y: D.y, type: 'heatmap',
          colorscale: [[0,'green'],[0.5,'yellow'],[1,'red']],
          zmin: +zMin.value, zmax: +zMax.value,
          customdata: D.ar.map((r,i) => r.map((_,j) => [D.ar[i][j], D.md[i][j], D.cm[i][j], H[i][j]])),
          hovertemplate: 'AR: %{customdata[0]:.2%}<br>MD: %{customdata[1]:.2%}<br>Calmar: %{customdata[2]:.2f}<br>H: %{customdata[3]:.3f}<extra></extra>'
        },
        {
          z: mask, x: D.x, y: D.y, type: 'heatmap', showscale: false,
          colorscale: [[0,'rgba(0,0,0,0)'],[1,'rgba(0,0,0,0.5)']], hoverinfo: 'skip'
        }
      ], {
        margin:{l:60,r:60,t:60,b:60}, xaxis:{title:'RSI'}, yaxis:{title:'Lookback (days)'}
      }, {responsive:true});

      heatDiv.on('plotly_hover', ev => {
        const pt = ev.points[0];
        hoverX.innerText = 'RSI: ' + pt.x;
        hoverY.innerText = 'Day: ' + pt.y;
      });
      heatDiv.on('plotly_unhover', () => { hoverX.innerText=''; hoverY.innerText=''; });
    }
  </script>
</body>
</html>
