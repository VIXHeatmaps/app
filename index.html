<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Heatmap Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    .formula { font-style: italic; margin-bottom: 20px; }
    .header { display: flex; justify-content: space-between; align-items: flex-start; }
    .controls { flex: 1; }
    .upload-box { border: 1px solid #ccc; padding: 8px; border-radius: 6px; }
    .control { margin-bottom: 12px; }
    label { font-weight: bold; margin-right: 8px; }
    input[type=range] { width: 250px; vertical-align: middle; }
    input[type=number] { width: 60px; margin-left: 8px; }
    #currentMaxH { margin-left: 12px; font-weight: bold; }
    #edgeContainer { display: flex; align-items: flex-start; }
    #hoverY { width: 80px; text-align: right; margin-right: 8px; min-height: 60vh; line-height: 60vh; }
    #heatmap { flex: 1; height: 60vh; }
    #hoverX-container { display: flex; justify-content: center; margin-top: 8px; }
    #hoverX { font-style: italic; color: #333; }
    #otherSourceBox { width: 80px; font-size: 0.9em; margin-left: 6px; }
    #clearDataBtn { margin-left: 12px; padding: 2px 12px; border-radius: 6px; border: 1px solid #aaa; background: #fafafa; cursor: pointer; }
    #clearDataBtn:hover { background: #eee; }
    #exportCSVBtn { margin-top: 10px; padding: 2px 12px; border-radius: 6px; border: 1px solid #aaa; background: #fafafa; cursor: pointer; }
    #exportCSVBtn:hover { background: #eee; }
  </style>
</head>
<body>
  <h2>Heatmap Viewer</h2>
  <div class="formula">
    <strong>Metric:</strong> H = (AR – AR<sub>min</sub>) / max(MD, MD<sub>min</sub>) (decimal)
  </div>
  <div class="header">
    <div class="controls">
      <div class="control" style="display: flex; align-items: center;">
        <label>Symbol:</label>
        <select id="symbolSelect"></select>
        <button id="clearDataBtn">Clear Data</button>
      </div>
      <div class="control"><label>AR Min. (%):</label>
        <input type="range" id="arFloor" min="0" max="100" step="0.1" value="3">
        <input type="number" id="arFloorNum" min="0" max="100" step="0.1" value="3">
      </div>
      <div class="control"><label>MD Min. (%):</label>
        <input type="range" id="mdMin" min="0" max="100" step="0.1" value="5">
        <input type="number" id="mdMinNum" min="0" max="100" step="0.1" value="5">
      </div>
      <div class="control"><label>MD Max (%):</label>
        <input type="range" id="mdCeil" min="0" max="100" step="0.1" value="50">
        <input type="number" id="mdCeilNum" min="0" max="100" step="0.1" value="50">
      </div>
      <div class="control"><label>Colorbar Min H:</label>
        <input type="number" id="zMin" step="0.01" value="-1">
        <label>Colorbar Max H:</label>
        <input type="number" id="zMax" step="0.01" value="1">
        <span id="currentMaxH">Current Max H: --</span>
      </div>
    </div>
    <div class="upload-box">
      <div class="control">
        <label>Data Source:</label>
        <select id="dataSourceSelect">
          <option>Exxahub</option>
          <option>Testfol.io</option>
          <option>Composer</option>
          <option>Quantmage</option>
          <option>Other</option>
        </select>
        <input type="text" id="otherSourceBox" placeholder="Type here" style="display:none;" />
      </div>
      <div class="control">
        <label><input type="checkbox" id="decimalToPercentBox"> Decimal → %</label>
        <span style="font-size:0.9em; color:#555;">(select prior to upload)</span>
      </div>
      <div class="control"><label>Upload CSV:</label><input type="file" id="csvInput" accept=".csv"></div>
      <button id="exportCSVBtn">Export CSV</button>
    </div>
  </div>
  <div id="edgeContainer"><div id="hoverY"></div><div id="heatmap"></div></div>
  <div id="hoverX-container"><div id="hoverX"></div></div>
  <script>
    let allData = {};
    let rawText = null;
    const csvInput = document.getElementById('csvInput'),
          symbolSelect = document.getElementById('symbolSelect'),
          arFloor = document.getElementById('arFloor'),
          arFloorNum = document.getElementById('arFloorNum'),
          mdMin = document.getElementById('mdMin'),
          mdMinNum = document.getElementById('mdMinNum'),
          mdCeil = document.getElementById('mdCeil'),
          mdCeilNum = document.getElementById('mdCeilNum'),
          zMin = document.getElementById('zMin'),
          zMax = document.getElementById('zMax'),
          hoverX = document.getElementById('hoverX'),
          hoverY = document.getElementById('hoverY'),
          currentMaxH = document.getElementById('currentMaxH'),
          heatDiv = document.getElementById('heatmap'),
          dataSourceSelect = document.getElementById('dataSourceSelect'),
          otherSourceBox = document.getElementById('otherSourceBox'),
          clearDataBtn = document.getElementById('clearDataBtn'),
          decimalToPercentBox = document.getElementById('decimalToPercentBox'),
          exportCSVBtn = document.getElementById('exportCSVBtn');

    // Show/hide "Other" input
    dataSourceSelect.addEventListener('change', () => {
      otherSourceBox.style.display = dataSourceSelect.value === "Other" ? "" : "none";
    });

    // CLEAR DATA BUTTON
    clearDataBtn.addEventListener('click', () => {
      allData = {};
      symbolSelect.innerHTML = '';
      Plotly.purge(heatDiv);
      hoverX.innerText = '';
      hoverY.innerText = '';
      currentMaxH.textContent = 'Current Max H: --';
    });

    // AUTOLOAD CSV ON PAGE LOAD (default source = "Exxahub")
    window.addEventListener('DOMContentLoaded', () => {
      fetch('data/LoadDataTQQQ.csv')
        .then(response => {
          if (!response.ok) throw new Error('Network response was not ok');
          return response.text();
        })
        .then(csvText => {
          rawText = csvText;
          buildFromText(csvText, "Exxahub");
          populateSymbols();
        })
        .catch(error => {
          console.log('Autoload CSV error:', error);
        });
    });

    function populateSymbols() {
      symbolSelect.innerHTML = '';
      Object.keys(allData).forEach(s => {
        const opt = document.createElement('option');
        opt.value = opt.text = s;
        symbolSelect.appendChild(opt);
      });
      if (symbolSelect.options.length) {
        symbolSelect.selectedIndex = 0;
        drawHeatmap();
      }
    }

    csvInput.addEventListener('change', e => {
      const reader = new FileReader();
      reader.onload = evt => {
        rawText = evt.target.result;
        let source = dataSourceSelect.value;
        if (source === "Other") {
          source = otherSourceBox.value.trim() || "Other";
        }
        buildFromText(rawText, source);
        populateSymbols();
      };
      reader.readAsText(e.target.files[0]);
    });

    [arFloor, arFloorNum].forEach(el => el.oninput = () => {
      arFloor.value = arFloorNum.value = el.value;
      drawHeatmap();
    });
    [mdMin, mdMinNum].forEach(el => el.oninput = () => {
      mdMin.value = mdMinNum.value = el.value;
      drawHeatmap();
    });
    [mdCeil, mdCeilNum].forEach(el => el.oninput = () => {
      mdCeil.value = mdCeilNum.value = el.value;
      drawHeatmap();
    });
    [zMin, zMax].forEach(el => el.oninput = drawHeatmap);
    symbolSelect.onchange = drawHeatmap;

    // Accepts new param: source
    function buildFromText(text, source) {
      const lines = text.trim().split(/\r?\n/);
      if (!lines.length) return;

      const headerMap = {
        symbol: ['symbol', 'ticker', 'name'],
        day: ['day', 'days', 'timeframe', 'window', 'period', 'lookback'],
        rsi: ['rsi', 'relative strength index'],
        ar: ['ar', 'annualized return', 'cagr'],
        md: ['md', 'max drawdown', 'drawdown']
      };

      function findCol(headers, aliases) {
        for (let i = 0; i < headers.length; ++i) {
          const h = headers[i].trim().toLowerCase();
          if (aliases.includes(h)) return i;
        }
        return -1;
      }

      const headers = lines[0].split(',');
      const colIdx = {};
      Object.keys(headerMap).forEach(key => {
        const idx = findCol(
          headers,
          headerMap[key].map(s => s.toLowerCase())
        );
        if (idx === -1) {
          throw new Error(`Missing column for ${key} (${headerMap[key].join('/')})`);
        }
        colIdx[key] = idx;
      });

      // Store per-symbol per-source
      const temp = {};

      for (let i = 1; i < lines.length; ++i) {
        const c = lines[i].split(',');
        if (c.length < headers.length) continue;
        const symSource = c[colIdx.symbol] + " (" + source + ")";
        const d = +c[colIdx.day];
        const x = c[colIdx.rsi];
        let ar = parseFloat(c[colIdx.ar]), md = parseFloat(c[colIdx.md]);
        // Convert decimals to percent if checked
        if (decimalToPercentBox && decimalToPercentBox.checked) {
          ar *= 100;
          md *= 100;
        }
        const cm = (md === 0 ? null : ar / md);
        temp[symSource] = temp[symSource] || [];
        temp[symSource].push({ day: d, rsi: x, ar, md, cm });
      }

      // Merge into allData
      Object.keys(temp).forEach(s => {
        const arr = temp[s];
        const xs = Array.from(new Set(arr.map(o => o.rsi))).sort();
        const ys = Array.from(new Set(arr.map(o => o.day))).sort((a, b) => a - b);
        const arM = ys.map(y => xs.map(x => {
          const rec = arr.find(o => o.day === y && o.rsi === x);
          return rec ? rec.ar : null;
        }));
        const mdM = ys.map(y => xs.map(x => {
          const rec = arr.find(o => o.day === y && o.rsi === x);
          return rec ? rec.md : null;
        }));
        const cmM = ys.map(y => xs.map(x => {
          const rec = arr.find(o => o.day === y && o.rsi === x);
          return rec ? rec.cm : null;
        }));
        allData[s] = { x: xs, y: ys, ar: arM, md: mdM, cm: cmM };
      });
    }

    // All slider logic now uses raw percent units
    function computeH(ar, md, floor, minMD) {
      return ar.map((row, i) => row.map((v, j) => {
        if (v == null) return null;
        return (v - floor) / Math.max(md[i][j], minMD);
      }));
    }

    function drawHeatmap() {
      const s = symbolSelect.value;
      if (!s) return;
      const D = allData[s];
      const floor = +arFloor.value;
      const minMD = +mdMin.value;
      const ceilMD = +mdCeil.value;
      const zminVal = +zMin.value;
      const zmaxVal = +zMax.value;
      const H = computeH(D.ar, D.md, floor, minMD);

    // Improved mask: 0 = no mask, 1 = mask; handles 0 and 100 edge cases
const EPSILON = 1e-6;
let mask;
if (ceilMD <= EPSILON) {
  // Mask everything at 0
  mask = D.md.map(row => row.map(() => 1));
} else if (ceilMD >= 100 - EPSILON) {
  // Mask nothing at 100
  mask = D.md.map(row => row.map(() => 0));
} else {
  // Mask only values above the slider
  mask = D.md.map(row => row.map(v => (v != null && v > ceilMD) ? 1 : 0));
}



      // Compute current max H
      let maxH = -Infinity;
      H.forEach(row => row.forEach(v => { if (v != null && v > maxH) maxH = v; }));
      currentMaxH.textContent = 'Current Max H: ' + maxH.toFixed(3);

      Plotly.newPlot(heatDiv, [
        {
          z: H,
          x: D.x,
          y: D.y,
          type: 'heatmap',
          colorscale: [[0, 'green'], [0.5, 'yellow'], [1, 'red']],
          zmin: zminVal,
          zmax: zmaxVal,
          customdata: D.ar.map((r, i) => r.map((_, j) => [D.ar[i][j], D.md[i][j], D.cm[i][j], H[i][j]])),
          hovertemplate: 'AR: %{customdata[0]:.2f}%<br>MD: %{customdata[1]:.2f}%<br>Calmar: %{customdata[2]:.2f}<br>H: %{customdata[3]:.3f}<extra></extra>'
        },
        {
          z: mask,
          x: D.x,
          y: D.y,
          type: 'heatmap',
          showscale: false,
          colorscale: [[0, 'rgba(0,0,0,0)'], [1, 'rgba(0,0,0,0.5)']],
          hoverinfo: 'skip'
        }
      ], {
        margin: { l: 60, r: 60, t: 60, b: 60 },
        xaxis: { title: 'RSI Threshold' },
        yaxis: { title: 'Lookback (days)' }
      }, { responsive: true });
      // Edge labels on hover
      heatDiv.on('plotly_hover', function(eventData) {
        var pt = eventData.points[0];
        document.getElementById('hoverX').innerText = 'RSI: ' + pt.x;
        document.getElementById('hoverY').innerText = 'Day: ' + pt.y;
      });
      heatDiv.on('plotly_unhover', function() {
        document.getElementById('hoverX').innerText = '';
        document.getElementById('hoverY').innerText = '';
      });
    }

    // ---- CSV Export Functionality ----
    exportCSVBtn.addEventListener('click', function() {
      // Get slider values
      const floor = +arFloor.value;
      const minMD = +mdMin.value;
      const ceilMD = +mdCeil.value;
      const hColName = `H (Rmin${floor}|Dmin${minMD}|Dmax${ceilMD})`;

      // CSV Header
      let csv = `Symbol,Days,RSI,AR,MD,Calmar,${hColName}\n`;
      Object.keys(allData).forEach(symbol => {
        const D = allData[symbol];
        const H = computeH(D.ar, D.md, floor, minMD);
        for (let i = 0; i < D.y.length; ++i) {
          for (let j = 0; j < D.x.length; ++j) {
            if (D.ar[i][j] == null) continue;
            csv += [
              `"${symbol}"`,
              D.y[i],
              D.x[j],
              D.ar[i][j],
              D.md[i][j],
              (D.cm[i][j] == null ? "" : D.cm[i][j]),
              (H[i][j] == null ? "" : H[i][j].toFixed(5))
            ].join(",") + "\n";
          }
        }
      });
      // Download
      const blob = new Blob([csv], {type: "text/csv"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "merged_heatmap_data.csv";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 0);
    });
  </script>
</body>
</html>
